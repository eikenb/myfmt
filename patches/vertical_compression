--- a/gofmt.go
+++ b/gofmt.go
@@ -10,7 +10,7 @@
 	"fmt"
 	"go/ast"
 	"go/parser"
-	"go/printer"
+	"myfmt/printer"
 	"go/scanner"
 	"go/token"
 	"io"
--- a/printer/nodes.go
+++ b/printer/nodes.go
@@ -936,8 +936,40 @@
 	}
 }
 
+// from vertical_compression patchset
+func (p *printer) compressedBlock(b *ast.BlockStmt) bool {
+	if len(b.List) == 1 {
+		// eg. the statement ('if ... {', 'for ... {', etc)
+		st_pos, st_end := b.Pos(), b.End()
+		_ = st_end
+		// the expression block
+		e_pos, e_end := b.List[0].Pos(), b.List[0].End()
+		// check that expression isn't multi-line
+		if (p.lineFor(e_end) - p.lineFor(e_pos)) == 0 {
+			// if short enough, keep on same line
+			// starting column of block (opening {) - sans tab chars
+			col := p.posFor(st_pos).Column - p.indent
+			// indent in displayed chars
+			indent := p.indent * p.Config.Tabwidth
+			end_bracket_w_padding := 3 // hardcoded below
+			block_len := int(e_end-e_pos) + end_bracket_w_padding
+			if (block_len + indent + col) < 78 {
+				p.print(b.Pos(), token.LBRACE, blank)
+				p.stmt(b.List[0], true)
+				p.print(blank, b.Rbrace, token.RBRACE)
+				return true
+			}
+		}
+	}
+	return false
+}
+
 // block prints an *ast.BlockStmt; it always spans at least two lines.
 func (p *printer) block(b *ast.BlockStmt, nindent int) {
+	// from vertical_compression patchset
+	if p.compressedBlock(b) {
+		return
+	}
 	p.print(b.Lbrace, token.LBRACE)
 	p.stmtList(b.List, nindent, true)
 	p.linebreak(p.lineFor(b.Rbrace), 1, ignore, true)
