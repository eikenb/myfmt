--- a/gofmt.go
+++ b/gofmt.go
@@ -10,7 +10,7 @@
 	"fmt"
 	"go/ast"
 	"go/parser"
-	"go/printer"
+	"myfmt/printer"
 	"go/scanner"
 	"go/token"
 	"io"
--- a/printer/nodes.go
+++ b/printer/nodes.go
@@ -915,8 +915,35 @@
 	}
 }
 
+// from vertical_compression patchset
+func (p *printer) tryCompressed(b *ast.BlockStmt) bool {
+	if len(b.List) == 1 {
+		// eg. the statement ('if ... {', 'for ... {', etc)
+		st_pos, st_end := b.Pos(), b.End()
+		// the expression block
+		e_pos, e_end := b.List[0].Pos(), b.List[0].End()
+		// starting column of statement
+		col := p.posFor(st_pos).Column
+		// check that expression isn't multi-line
+		if (p.lineFor(e_end) - p.lineFor(e_pos)) == 0 {
+			// if short enough, keep on same line
+			if (int(st_end - st_pos) + int(e_end - e_pos) + col + 1) < 78 {
+				p.print(b.Pos(), token.LBRACE, blank)
+				p.stmt(b.List[0], true)
+				p.print(blank, b.Rbrace, token.RBRACE)
+				return true
+			}
+		}
+	}
+	return false
+}
+
 // block prints an *ast.BlockStmt; it always spans at least two lines.
 func (p *printer) block(b *ast.BlockStmt, nindent int) {
+	// from vertical_compression patchset
+	if p.tryCompressed(b) {
+		return
+	}
 	p.print(b.Lbrace, token.LBRACE)
 	p.stmtList(b.List, nindent, true)
 	p.linebreak(p.lineFor(b.Rbrace), 1, ignore, true)
